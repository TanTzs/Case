
<!-- README.md is generated from README.Rmd. Please edit that file -->

# Case

<!-- badges: start -->
<!-- badges: end -->

`Case`包是为了帮助实现教材中的各个案例所编写的程序包,
包含了实现如何复现iVX、如何预测股票波动率等目的的函数。

## 0 安装说明

``` r
# 可通过github网站下载本包，然后通过RStudio进行本地安装
# 安装后导入即可使用其中包含的数据集及相关函数。
library(Case)
#> Registered S3 method overwritten by 'quantmod':
#>   method            from
#>   as.zoo.data.frame zoo
```

## 1 数据集介绍

### 1.1 option_data

`option_data`数据集包含了自2015年2月9日至2024年5月21日的288756条期权数据，包括了交易日期、类型、到期日期、执行价以及收盘价，可用于计算中国波指iVX。数据样式如下:

``` r
head(option_data)
#>     交易日期 类型   到期日期 执行价 收盘价
#> 1 2015-02-09 看涨 2015-03-25   2.20 0.1826
#> 2 2015-02-09 看涨 2015-03-25   2.25 0.1460
#> 3 2015-02-09 看涨 2015-03-25   2.30 0.1225
#> 4 2015-02-09 看涨 2015-03-25   2.35 0.0942
#> 5 2015-02-09 看涨 2015-03-25   2.40 0.0735
#> 6 2015-02-09 看跌 2015-03-25   2.20 0.0617
```

### 1.2 iVX

`iVX`数据集包含了自2015年2月9日至2018年2月7日的739条中国波指iVX的数据，包括了日期和iVX的值，数据由同花顺公司提供，可用于与计算得到iVX进行对比。数据样式如下:

``` r
head(iVX)
#>         date   iVX
#> 1 2015-02-09 28.63
#> 2 2015-02-10 28.75
#> 3 2015-02-11 26.44
#> 4 2015-02-12 25.80
#> 5 2015-02-13 23.41
#> 6 2015-02-16 23.71
```

### 1.3 etf50

`etf50`数据集包含了自2017年1月3日至2023年12月29日的1701条上证50ETF的数据，包括了日期和上证50ETF的值，数据可由聚宽平台得到，可用于交易回测。数据样式如下:

``` r
head(etf50)
#>         date etf50
#> 1 2017-01-03 3.142
#> 2 2017-01-04 3.158
#> 3 2017-01-05 3.160
#> 4 2017-01-06 3.144
#> 5 2017-01-09 3.155
#> 6 2017-01-10 3.148
```

### 1.4 moutai_data

`moutai_data`数据集包含了自2012年1月4日至2023年12月29日的1701条贵州茅台的五分钟高频数据，数据可从锐思数据得到。数据样式如下:

``` r
moutai_data[1:10,(ncol(moutai_data)-1):ncol(moutai_data)]
#>       2023-12-28 2023-12-29
#> 09:30   2087.467   2138.477
#> 09:35   2096.307   2147.477
#> 09:40   2096.457   2151.007
#> 09:45   2104.977   2149.977
#> 09:50   2106.477   2158.277
#> 09:55   2109.347   2155.647
#> 10:00   2108.177   2160.377
#> 10:05   2110.507   2166.417
#> 10:10   2115.997   2159.487
#> 10:15   2115.477   2158.607
```

## 2 案例一相关函数

### 2.1 iVXCalc()

`iVXCalc(data,rate)`函数可根据提供的期权数据，对中国波指iVX进行估计，其中`data`参数要求形式与`option_data`相同的数据框，`rate`可为常数或者与`data`中日期跨度相同长度的向量。下面为示例：

``` r
iVX_est = iVXCalc(option_data[1:1000,],rate = 0.04) # rate为常数，估计iVX
```

``` r
head(na.omit(iVX_est)) # 输出iVX的估计结果
#>         date  iVX_est
#> 1 2015-02-09 22.04162
#> 2 2015-02-10 22.59798
#> 3 2015-02-11 21.02701
#> 4 2015-02-12 21.39366
#> 5 2015-02-13 19.39122
#> 6 2015-02-16 19.75719
```

### 2.2 backtesting()

`backtesting(Cash,amount_per,date,signal,stock,buy_signal,sell_signal)`是一个简单的策略回测函数，其策略为:当`signal`高于`buy_signal`，则买入`amount_per`金额的股票；当`signal`低于`sell_signal`时，则卖出上一时刻买入的股票份数的股票。回测过程假设不存在手续费、股票份数无限可分。结果将返回一个数据框，其包含`回测日期`、`strategy`以及`baseline`三列，`strategy`列为使用策略后每天的持有的股票与现金总资产`，baseline`为一开始全仓买入标的资产后的总资产。

下面为代码示例:

``` r
library(lubridate)
#> 
#> Attaching package: 'lubridate'
#> The following objects are masked from 'package:base':
#> 
#>     date, intersect, setdiff, union
```

``` r
cash = 1000 # 初始设置为资金为1000元
amount_per = 100 # 每次买入100元的股票

start_date <- Sys.Date()
date <- seq.Date(from = start_date, by = "day", length.out = 100)

# 回测周期
signal = abs(rnorm(100,mean = 20, sd = 20)) # 信号
stock = abs(rnorm(100, mean = 10, sd = 10)) # 标的

buy_signal = 30 # 买入信号
sell_signal = 20 # 卖出信号
result = backtesting(cash,amount_per,date,signal,stock,buy_signal,sell_signal) # 策略结果

head(result)
#>         date  strategy  baseline
#> 1 2024-09-03 1000.0000 1000.0000
#> 2 2024-09-04 1088.7905 1887.9051
#> 3 2024-09-05  956.6054  566.0537
#> 4 2024-09-06 1184.3035 2843.0353
#> 5 2024-09-07 1026.5765  409.9644
#> 6 2024-09-08 1156.4793 2413.8228
```

## 3 案例二相关函数

### 3.1 har_rv()

`har_rv(data,fore_L,tau)`是一个基于HAR-RV及ARMA(1,1)模型，用于预测收益率、波动率和在险价值(VaR)的函数.
`data`变量为包含价格数据的数据框，每一列代表该天的高频价格数据;
`fore_L`则用于确定将`data`中的后`fore_L`列作为预测对象，`tau`为VaR所用的分位数。该函数将返回一个`fore_L`行\*4列的数据框，分别表示预测的收益率、已实现波动率、基于HAR-RV和ARMA(1,1)的历史滤波模拟法得到的VaR预测以及历史滤波模拟法得到的VaR预测，代码示例如下:

``` r
rv_var = har_rv(moutai_data,5,0.05)
```

``` r
rv_var
#>      return_est       rv_est    VaR_est     VaR_hs
#> 1  6.452740e-04 9.053514e-05 0.01412996 0.01739796
#> 2  7.780949e-04 8.352796e-05 0.01341172 0.01739796
#> 3  8.394235e-04 7.390862e-05 0.01251169 0.01739796
#> 4 -1.282137e-04 7.093626e-05 0.01322016 0.01739796
#> 5  9.034955e-05 8.631402e-05 0.01435878 0.01739796
```

### 3.2 garch()

`garch(data,fore_L,tau)`是一个基于GARCH(1,1)及ARMA(1,1)模型，用于预测收益率、波动率和在险价值(VaR)的函数.
`data`变量为包含价格数据的数据框，每一列代表该天的高频价格数据;
`fore_L`则用于确定将`data`中的后`fore_L`列作为预测对象，`tau`为VaR所用的分位数。该函数将返回一个`fore_L`行\*3列的数据框，分别表示预测的收益率、已实现波动率、基于GARCH(1,1)和ARMA(1,1)的历史滤波模拟法得到的VaR预测，代码示例如下:

``` r
rv_var = garch(moutai_data,5,0.05)
```

``` r
rv_var
#>     return_est       rv_est    VaR_est
#> 1 0.0004097611 9.711321e-05 0.01474769
#> 2 0.0005330007 9.155572e-05 0.01417361
#> 3 0.0006688386 8.652967e-05 0.01363549
#> 4 0.0007360824 8.192918e-05 0.01317846
#> 5 0.0008376075 1.145032e-04 0.01564475
```

### 3.3 rgarch()

`rgarch(data,fore_L,tau)`是一个基于RGARCH(1,1)及ARMA(1,1)模型，用于预测收益率、波动率和在险价值(VaR)的函数.
`data`变量为包含价格数据的数据框，每一列代表该天的高频价格数据;
`fore_L`则用于确定将`data`中的后`fore_L`列作为预测对象，`tau`为VaR所用的分位数。该函数将返回一个`fore_L`行\*3列的数据框，分别表示预测的收益率、已实现波动率、基于RGARCH(1,1)和ARMA(1,1)的历史滤波模拟法得到的VaR预测，代码示例如下:

``` r
rv_var = rgarch(moutai_data,5,0.05)
```

``` r
rv_var
#>     return_est       rv_est    VaR_est
#> 1 0.0004546732 1.493854e-04 0.01800387
#> 2 0.0005196259 1.161914e-04 0.01570489
#> 3 0.0005705980 9.016460e-05 0.01371817
#> 4 0.0005842852 8.354304e-05 0.01317918
#> 5 0.0008207783 1.192324e-04 0.01560403
```

### 3.4 heavy()

`rgarch(data,fore_L,tau)`是一个基于HEAVY及ARMA(1,1)模型，用于预测收益率、波动率和在险价值(VaR)的函数.
`data`变量为包含价格数据的数据框，每一列代表该天的高频价格数据;
`fore_L`则用于确定将`data`中的后`fore_L`列作为预测对象，`tau`为VaR所用的分位数。该函数将返回一个`fore_L`行\*3列的数据框，分别表示预测的收益率、已实现波动率、基于HEAVY和ARMA(1,1)的历史滤波模拟法得到的VaR预测，代码示例如下:

``` r
rv_var = heavy(moutai_data,5,0.05)
```

``` r
rv_var
#>     return_est       rv_est    VaR_est
#> 1 0.0005422047 9.658463e-05 0.01447490
#> 2 0.0006683811 8.493590e-05 0.01336816
#> 3 0.0007988817 7.408559e-05 0.01229536
#> 4 0.0008752367 7.337154e-05 0.01213440
#> 5 0.0008643660 1.409427e-04 0.01705365
```
